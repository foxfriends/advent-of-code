import "trilogy:debug" use dbg
import "trilogy:io" use readlines
import "trilogy:parsec" use parse, sep_by, char, integer, per_line
import "trilogy:array" use collect
import "trilogy:core" use length
import "trilogy:iterator" as it
import "trilogy:set" use union
import "trilogy:heap" use heap

func dist [x1, y1, z1]:[x2, y2, z2] = (x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2
func dist_asc a b = dist a <= dist b

proc main!() {
  let points = readlines
    |> it::map (parse (sep_by (char ',') integer))
    |> collect

  let edge_heap = heap dist_asc

  let mut edges = []
  let mut i = 0
  while i < length points {
    let mut j = i + 1
    while j < length points {
      edge_heap::push!(edges, points.i:points.j)
      j += 1
    }
    i += 1
  }

  let mut sets = {| pos => [| pos |] for pos in points |}
  let mut i = 0
  while length edges > 0 {
    i += 1
    let a:b = edge_heap::pop!(edges)
    if sets.a == sets.b { continue unit }
    sets.a union= sets.b
    if length (sets.a) == length points {
      dbg!(a.0 * b.0)
      return 0
    }
    for el in sets.a { # NOTE: this for loop is the slowest part...
      sets.el = sets.a
    }
  }
}
