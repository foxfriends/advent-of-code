import "trilogy:io" use readlines
import "trilogy:debug" use dbg
import "trilogy:core" use to_array, length
import "trilogy:bits" as bits
import "trilogy:set" use contains, union, collect, difference
import "trilogy:compare" use min
import "trilogy:parsec" use parse, apply, between, many_1, char_of, char, integer, sep_by_1
import "trilogy:array" use map, fold, filter, reverse
import "trilogy:iterator" as it

proc machine!() {
  let _target = apply
    <| between (char '[') (char ']')
    <| many_1
    <| char_of ".#"
  apply <| char ' '
  let buttons = apply
    <| sep_by_1 (char ' ')
    <| between (char '(') (char ')')
    <| sep_by_1 (char ',') integer
  apply <| char ' '
  let joltage = fold (fn acc n. n:acc) unit
    <| reverse
    <| apply
    <| between (char '{') (char '}')
    <| sep_by_1 (char ',') integer
  return joltage:buttons
}

func update_state n:rest 0 = n + 1 : rest
func update_state n:rest i = n : update_state rest (i - 1)

func press_button state [] = state
func press_button state [n, ..rest] = press_button (update_state state n) rest

func below unit unit = true
func below a:ra b:rb = if b <= a then below ra rb else false

func zero unit = unit
func zero _ : rest = 0 : zero rest

proc solve!(target:buttons) {
  let mut visited = [| zero target |]
  let mut states = [| zero target |]
  let mut i = 0
  while !(contains target states) {
    dbg!(i)
    let new_states = states
      |> it::from
      |> it::flat_map (fn state. it::from <| map (press_button state) buttons)
      |> it::filter (below target)
      |> collect
    states = difference new_states visited
    visited union= new_states
    i += 1
  }
  return i
}

proc main!() {
  readlines
  |> it::map (parse machine)
  |> it::map dbg
  |> it::map solve
  |> it::map dbg
  |> it::fold (+) 0
  |> dbg
}
