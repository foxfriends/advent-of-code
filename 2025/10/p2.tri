import "trilogy:io" use readlines
import "trilogy:debug" use dbg
import "trilogy:core" use to_array, length
import "trilogy:bits" as bits
import "trilogy:compare" use min
import "trilogy:parsec" use parse, apply, between, many_1, char_of, char, integer, sep_by_1
import "trilogy:array" use map, fold, filter, reduce, all, prepend
import "trilogy:set" use contains, difference, union, collect
import "trilogy:record" use contains_key
import "trilogy:iterator" as it

func target_state '.' = false
func target_state '#' = true

func set_bit bb index = bb | (0bb1 ~~> index)

func button_bits len button = fold set_bit (bits::init_zero len) button

proc machine!() {
  let target = bits::from_array
    <| map target_state
    <| apply
    <| between (char '[') (char ']')
    <| many_1
    <| char_of ".#"
  apply <| char ' '
  let buttons = apply
    <| sep_by_1 (char ' ')
    <| between (char '(') (char ')')
    <| sep_by_1 (char ',') integer
  apply <| char ' '
  let joltage = apply
    <| between (char '{') (char '}')
    <| sep_by_1 (char ',') integer
  return joltage:solver buttons
}

func decr_at 0 [m, ..arr] = [m - 1, ..arr]
func decr_at i [m, ..arr] = [m, ..decr_at (i - 1) arr]

func apply_button target [] = target
func apply_button target [i, ..rest] = apply_button (decr_at i target) rest

func solve_bits buttons target =
  it::range 1 (length buttons)
  |> it::flat_map (fn n. it::choose n buttons)
  |> it::filter ((==) target << reduce (^) << map (button_bits (length target)))

proc solver!(buttons) {
  let cache = {||}

  let solve = do(joltage) {
    if contains_key joltage cache {
      return cache.joltage
    }
    if all ((==) 0) joltage {
      return 0
    }
    if all (fn n. n % 2 == 0) joltage {
      return solve!(map (fn n. n // 2) joltage) * 2
    }
    let best = joltage
      |> map (fn n. n % 2 == 1)
      |> bits::from_array
      |> solve_bits buttons
      |> it::map (fn sol. fold apply_button joltage sol : length sol)
      |> it::filter (fn remaining:_. all (fn n. n >= 0) remaining)
      |> it::flat_map (fn remaining:score. with it::of <| solve!(map (fn n. n // 2) remaining) * 2 + score when 'mia cancel (do() {}) else yield)
      |> it::reduce min
    cache.joltage = best
    return best
  }

  return solve
}

proc main!() {
  readlines
  |> it::map (parse machine)
  |> it::map (fn joltage:solve. solve!(joltage))
  |> it::fold (+) 0
  |> dbg
}
