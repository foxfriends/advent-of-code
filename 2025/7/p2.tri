import "trilogy:debug" use dbg
import "trilogy:io" use readlines
import "trilogy:string" use split, chomp
import "trilogy:number" use im
import "trilogy:compare" use max
import "trilogy:array" use map, reduce, length
import "trilogy:set" use push, contains, collect
import "trilogy:iterator" as it

proc collect_input!(it) {
  let mut start = unit
  let mut splitters = [||]
  with it!() {
    when 'next(pos:'S') then {
      start = pos
      become unit
    }
    when 'next(pos:'^') then {
      push!(splitters, pos)
      become unit
    }
    when 'next(_) resume unit
  }
  return start:splitters
}

proc main!() {
  let start:splitters = collect_input!(
    readlines
    |> it::map (it::enumerate << it::from << chomp)
    |> it::enumerate
    |> it::flat_map (fn y:inner. it::map (fn x:v. x + y * 1i : v) inner)
  )
  let max_y = reduce max <| [im pos for pos in splitters]
  let mut splits = 0
  let mut i = 0
  let mut beams = {|start => 1|}
  while i <= max_y {
    beams = beams
      |> it::from
      |> it::flat_map (fn beam:val. if contains beam splitters then it::from [beam + 1 + 1i: val, beam - 1 + 1i: val] else it::of (beam + 1i:val))
      |> it::fold (fn rec pos:val. {| ..rec, pos => val + with rec.pos { when 'mia cancel 0 } |}) {||}
    i += 1
  }
  dbg!(reduce (+) [val for _:val in beams])
}
