import "trilogy:debug" use dbg
import "trilogy:io" use readall
import "trilogy:core" use length
import "trilogy:parsec" use apply, parse, sep_by, string, integer
import "trilogy:array" use collect
import "trilogy:set" as set
import "trilogy:iterator" as it
import "trilogy:tuple" use right
import "trilogy:number" use is_integer

proc input!() {
  apply <| string "target area: x="
  let [x_min, x_max] = apply <| sep_by (string "..") integer
  apply <| string ", y="
  let [y_min, y_max] = apply <| sep_by (string "..") integer
  return (x_min:x_max):(y_min:y_max)
}

func h_vel lim _ 0 = do() unit
func h_vel lim pos vel = do() {
  let next_pos = pos + vel
  if next_pos > lim { return unit }
  yield 'next(next_pos)
  let rest = h_vel lim next_pos (vel - 1)
  rest!()
}

func x_at 0 _ = 0
func x_at _ 0 = 0
func x_at t h = h + x_at (t - 1) (h - 1)

func in_range low high n = low <= n && n <= high

proc main!() {
  let (x_min:x_max):(y_min:y_max) = parse input readall!()

  let h_candidates = it::range 1 x_max
    |> it::filter (it::any (in_range x_min x_max) << h_vel x_max 0)
    |> collect

  it::range y_min y_max
    |> it::flat_map (fn y.
      it::range 1 1_000 # time
      |> it::map (fn t. t:(y + (t * (t - 1) / 2)) / t) # t:y velocity to hit target
      |> it::filter (right >> is_integer) # integer velocities only
      |> it::flat_map (fn t:v. it::from h_candidates |> it::map (fn h. t:v:h))
      |> it::filter (fn t:v:h. in_range x_min x_max <| x_at t h)
      |> it::map (fn _:v:h. v:h)
    )
    |> set::collect
    |> length
    |> dbg
}
