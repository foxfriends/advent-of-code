module io at "trilogy:io" use println, readlines
module str at "trilogy:str" use chomp, chars
module array at "trilogy:array" use transpose, split, length, filter
module iter at "trilogy:iter" use make_rangex, rangex, range, fold

proc north!(grid) {
    let w = length grid
    let h = length (grid.0)
    for col in rangex 0 w {
        let mut move_to = 0
        for row in rangex 0 h {
            match grid.row.col
                case '#' { move_to = row + 1 }
                case 'O' {
                    if move_to != row {
                        grid.move_to.col = 'O'
                        grid.row.col = '.'
                    }
                    move_to += 1
                }
        }
    }
}

proc west!(grid) {
    let w = length grid
    let h = length (grid.0)
    for row in rangex 0 h {
        let mut move_to = w - 1
        for uncol in range 1 w {
            let col = w - uncol
            match grid.row.col
                case '#' { move_to = col - 1 }
                case 'O' {
                    if move_to != row {
                        grid.row.move_to = 'O'
                        grid.row.col = '.'
                    }
                    move_to -= 1
                }
        }
    }
}

proc east!(grid) {
    let w = length grid
    let h = length (grid.0)
    for row in rangex 0 h {
        let mut move_to = 0
        for col in rangex 0 w {
            match grid.row.col
                case '#' { move_to = col + 1 }
                case 'O' {
                    if move_to != row {
                        grid.row.move_to = 'O'
                        grid.row.col = '.'
                    }
                    move_to += 1
                }
        }
    }
}

proc south!(grid) {
    let w = length grid
    let h = length (grid.0)
    for col in rangex 0 w {
        let mut move_to = h - 1
        for unrow in range 1 h {
            let row = h - unrow
            match grid.row.col
                case '#' { move_to = row - 1 }
                case 'O' {
                    if move_to != row {
                        grid.move_to.col = 'O'
                        grid.row.col = '.'
                    }
                    move_to -= 1
                }
        }
    }
}

proc spin!(grid) {
    north!(grid)
    west!(grid)
    south!(grid)
    east!(grid)
}

proc main!() {
    let mut total = 0
    let grid = [chars <| chomp line for line in readlines!()]
    for _ in rangex 0 (1000000000 / 4) {
        spin!(grid)
    }
    for col in transpose grid {
        let mut max_score = length col
        for segment in col |> split ((==) '#') {
            let count = segment |> filter ((==) 'O') |> length
            if count > 0 {
                total += fold (-) (max_score * count) (make_rangex 0 count)
            }
            max_score -= length segment + 1
        }
    }
    println!(total)
}
